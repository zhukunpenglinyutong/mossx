# Phase 2.1 — 项目记忆上下文注入 MVP（修正版）

> 创建：2026-02-11
> 修订：2026-02-11（对齐已确认设计 + 可执行细节）
> 状态：待执行

---

## 1. 目标

在不改 Rust command / 存储结构的前提下，在消息发送前自动注入“高价值且相关”的项目记忆，提升回答上下文一致性。

---

## 2. 决策对齐（与 research/04 一致）

1. 采用前端注入（方案 A）。
2. Phase 2.1 就接入本地开关：`projectMemory.contextInjectionEnabled`（默认 `true`）。
3. 注入格式固定 `<project-memory ...>`。
4. Fail-Open：任何注入异常都不阻塞发送。

---

## 3. 改动范围

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/features/project-memory/utils/memoryContextInjection.ts` | 新建 | 注入管线实现 |
| `src/features/project-memory/utils/memoryContextInjection.test.ts` | 新建 | 纯函数单测 |
| `src/features/threads/hooks/useThreadMessaging.ts` | 修改 | 接入注入与可观测性 |
| `src/features/threads/hooks/useThreadMessaging.context-injection.test.tsx` | 新建 | hook 级集成测试 |

不改动：Rust 后端、存储结构、`tauri.ts` 协议。

---

## 4. 关键实现细节（强约束）

### 4.1 开关读取（Phase 2.1 必做）

- Key：`projectMemory.contextInjectionEnabled`
- 默认：`true`
- 读取失败：回退 `true`

建议函数：

```ts
function readContextInjectionEnabled(): boolean
```

### 4.2 相关性规则（MVP）

- query 归一化：小写、去标点、去停用词、去重。
- 中文兜底：若中文文本无空格，启用 2-gram token（避免整句 token 导致全 0 命中）。
- 打分：`hitTerms / queryTerms.length`。
- 阈值：`RELEVANCE_THRESHOLD = 0.2`。
- importance 权重：`high=3, medium=2, low=1`（禁止字符串直接排序）。

### 4.3 预算与确定性

- 单条上限：`MAX_ITEM_CHARS = 200`
- 总量上限：`MAX_TOTAL_CHARS = 1000`
- 条数上限：`MAX_INJECT_COUNT = 5`
- 排序：`importanceWeight(desc) -> relevance(desc) -> updatedAt(desc) -> id(asc)`

### 4.4 安全与格式化

记忆内容进入 XML 块前必须清洗：

1. 清理控制字符。
2. 转义 `<`, `>`, `&`。
3. 替换 `</project-memory>` 字面串（防止闭合注入）。

建议函数：

```ts
function sanitizeForMemoryBlock(text: string): string
```

### 4.5 可观测性

在 `onDebug`（与必要 `console.warn`）中记录：

- `injected_count`
- `injected_chars`
- `retrieval_ms`
- `disabled_reason` (`switch_off|empty_result|low_relevance|query_failed`)

默认不打印记忆正文。

---

## 5. 实施步骤

### Step A：实现注入工具模块

文件：`src/features/project-memory/utils/memoryContextInjection.ts`

包含：

- `normalizeQueryTerms`
- `scoreMemoryRelevance`
- `selectContextMemories`
- `clampContextBudget`
- `formatMemoryContextBlock`
- `injectProjectMemoryContext`
- `sanitizeForMemoryBlock`
- 常量与类型（`InjectionResult`）

### Step B：接入发送链路

文件：`src/features/threads/hooks/useThreadMessaging.ts`

在 `expandCustomPromptText` 之后、双引擎发送前注入：

```ts
const enabled = readContextInjectionEnabled();
const injectionResult = await injectProjectMemoryContext({
  workspaceId: workspace.id,
  userText: finalText,
  enabled,
  listFn: projectMemoryFacade.list,
});
finalText = injectionResult.finalText;
```

并打 `onDebug` 埋点（注入成功/跳过原因）。

### Step C：测试

1. 纯函数测试：`memoryContextInjection.test.ts`
2. hook 集成测试：`useThreadMessaging.context-injection.test.tsx`

必须覆盖：

- `switch_off`
- `query_failed`
- `low_relevance`
- budget 截断
- 同输入同候选的确定性
- `useThreadMessaging` 真正发送文本含 `<project-memory>`（Claude/Codex 两条路径）

---

## 6. 验收标准（DoD）

1. 开关开启：发送文本前缀包含 `<project-memory>`。
2. 开关关闭：行为与当前版本一致。
3. 注入异常：消息仍发送成功（Fail-Open）。
4. 低相关：允许不注入，`disabled_reason=low_relevance`。
5. 输出确定性：同输入同记忆集结果一致。
6. hook 集成测试验证双引擎路径均可工作。

---

## 7. 验证命令（当前仓库可执行）

```bash
npx vitest run src/features/project-memory/utils/memoryContextInjection.test.ts --maxWorkers=1
npx vitest run src/features/threads/hooks/useThreadMessaging.context-injection.test.tsx --maxWorkers=1
npx tsc --noEmit
cd src-tauri && cargo test --lib project_memory
```

说明：避免直接 `npx vitest run` 全量，当前仓库存在历史 OOM 风险。

---

## 8. 回滚方案

1. 软回滚：`projectMemory.contextInjectionEnabled=false`。
2. 代码回滚：移除 `useThreadMessaging.ts` 注入调用。
3. 本次无后端/存储变更，无数据回滚需求。

---

## 9. 与旧计划关系

- 本文件替代旧版冗长草案，作为唯一执行计划。
- 旧计划保留归档，不建议硬删除（便于追溯）。

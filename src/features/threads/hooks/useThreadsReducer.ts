import type {
  AccountSnapshot,
  ApprovalRequest,
  ConversationItem,
  RateLimitSnapshot,
  RequestUserInputRequest,
  ThreadSummary,
  ThreadTokenUsage,
  TurnPlan,
} from "../../../types";
import { normalizeItem, prepareThreadItems, upsertItem } from "../../../utils/threadItems";

function formatThreadName(text: string) {
  const trimmed = text.trim();
  if (!trimmed) {
    return null;
  }
  return trimmed;
}

function looksAutoGeneratedThreadName(name: string) {
  return name.startsWith("Agent ") || /^[a-f0-9]{4,8}$/i.test(name);
}

function extractRenameText(text: string) {
  if (!text) {
    return "";
  }
  const withoutImages = text.replace(/\[image(?: x\d+)?\]/gi, " ");
  const withoutSkills = withoutImages.replace(/(^|\s)\$[A-Za-z0-9_-]+(?=\s|$)/g, " ");
  return withoutSkills.replace(/\s+/g, " ").trim();
}

function getAssistantTextForRename(
  items: ConversationItem[],
  itemId?: string,
): string {
  if (itemId) {
    const match = items.find(
      (item) =>
        item.kind === "message" &&
        item.role === "assistant" &&
        item.id === itemId,
    );
    if (match && match.kind === "message") {
      return match.text;
    }
  }
  for (let index = items.length - 1; index >= 0; index -= 1) {
    const item = items[index];
    if (item.kind === "message" && item.role === "assistant") {
      return item.text;
    }
  }
  return "";
}

function maybeRenameThreadFromAgent({
  workspaceId,
  threadId,
  items,
  itemId,
  hasCustomName,
  threadsByWorkspace,
}: {
  workspaceId: string;
  threadId: string;
  items: ConversationItem[];
  itemId?: string;
  hasCustomName: boolean;
  threadsByWorkspace: Record<string, ThreadSummary[]>;
}) {
  const threads = threadsByWorkspace[workspaceId] ?? [];
  if (!threads.length) {
    return threadsByWorkspace;
  }
  const hasUserMessage = items.some(
    (item) => item.kind === "message" && item.role === "user",
  );
  if (hasUserMessage) {
    return threadsByWorkspace;
  }
  if (hasCustomName) {
    return threadsByWorkspace;
  }
  const nextName = formatThreadName(getAssistantTextForRename(items, itemId));
  if (!nextName) {
    return threadsByWorkspace;
  }
  let didChange = false;
  const nextThreads = threads.map((thread) => {
    if (
      thread.id !== threadId ||
      thread.name === nextName ||
      !looksAutoGeneratedThreadName(thread.name)
    ) {
      return thread;
    }
    didChange = true;
    return { ...thread, name: nextName };
  });
  return didChange
    ? { ...threadsByWorkspace, [workspaceId]: nextThreads }
    : threadsByWorkspace;
}

function isFailedToolStatus(status: string) {
  return /(fail|error|cancel(?:led)?|abort|timeout|timed[_ -]?out)/.test(status);
}

function isCompletedToolStatus(status: string) {
  return /(complete|completed|success|done|finish(?:ed)?|succeed(?:ed)?)/.test(
    status,
  );
}

function isPendingToolStatus(status: string) {
  return /(pending|running|processing|started|in[_ -]?progress|inprogress|queued)/.test(
    status,
  );
}

type ThreadActivityStatus = {
  isProcessing: boolean;
  hasUnread: boolean;
  isReviewing: boolean;
  processingStartedAt: number | null;
  lastDurationMs: number | null;
  heartbeatPulse?: number;
};

export type ThreadState = {
  activeThreadIdByWorkspace: Record<string, string | null>;
  itemsByThread: Record<string, ConversationItem[]>;
  threadsByWorkspace: Record<string, ThreadSummary[]>;
  hiddenThreadIdsByWorkspace: Record<string, Record<string, true>>;
  threadParentById: Record<string, string>;
  threadStatusById: Record<string, ThreadActivityStatus>;
  threadListLoadingByWorkspace: Record<string, boolean>;
  threadListPagingByWorkspace: Record<string, boolean>;
  threadListCursorByWorkspace: Record<string, string | null>;
  activeTurnIdByThread: Record<string, string | null>;
  approvals: ApprovalRequest[];
  userInputRequests: RequestUserInputRequest[];
  tokenUsageByThread: Record<string, ThreadTokenUsage>;
  rateLimitsByWorkspace: Record<string, RateLimitSnapshot | null>;
  accountByWorkspace: Record<string, AccountSnapshot | null>;
  planByThread: Record<string, TurnPlan | null>;
  lastAgentMessageByThread: Record<string, { text: string; timestamp: number }>;
  // 流式消息分段：当 tool item 开始时增加，确保文本和工具交替显示
  agentSegmentByThread: Record<string, number>;
};

export type ThreadAction =
  | { type: "setActiveThreadId"; workspaceId: string; threadId: string | null }
  | {
      type: "ensureThread";
      workspaceId: string;
      threadId: string;
      engine?: "codex" | "claude" | "opencode";
    }
  | { type: "hideThread"; workspaceId: string; threadId: string }
  | { type: "removeThread"; workspaceId: string; threadId: string }
  | { type: "setThreadParent"; threadId: string; parentId: string }
  | {
      type: "markProcessing";
      threadId: string;
      isProcessing: boolean;
      timestamp: number;
    }
  | { type: "markHeartbeat"; threadId: string; pulse: number }
  | {
      type: "finalizePendingToolStatuses";
      threadId: string;
      status: "completed" | "failed";
    }
  | { type: "markReviewing"; threadId: string; isReviewing: boolean }
  | { type: "markUnread"; threadId: string; hasUnread: boolean }
  | { type: "addAssistantMessage"; threadId: string; text: string }
  | { type: "setThreadName"; workspaceId: string; threadId: string; name: string }
  | {
      type: "setThreadEngine";
      workspaceId: string;
      threadId: string;
      engine: "codex" | "claude" | "opencode";
    }
  | {
      type: "setThreadTimestamp";
      workspaceId: string;
      threadId: string;
      timestamp: number;
    }
  | {
      type: "appendAgentDelta";
      workspaceId: string;
      threadId: string;
      itemId: string;
      delta: string;
      hasCustomName: boolean;
    }
  | {
      type: "completeAgentMessage";
      workspaceId: string;
      threadId: string;
      itemId: string;
      text: string;
      hasCustomName: boolean;
    }
  | {
      type: "upsertItem";
      workspaceId: string;
      threadId: string;
      item: ConversationItem;
      hasCustomName?: boolean;
    }
  | { type: "setThreadItems"; threadId: string; items: ConversationItem[] }
  | {
      type: "appendReasoningSummary";
      threadId: string;
      itemId: string;
      delta: string;
    }
  | {
      type: "appendReasoningSummaryBoundary";
      threadId: string;
      itemId: string;
    }
  | {
      type: "appendContextCompacted";
      threadId: string;
      turnId: string;
    }
  | { type: "appendReasoningContent"; threadId: string; itemId: string; delta: string }
  | { type: "appendToolOutput"; threadId: string; itemId: string; delta: string }
  | { type: "setThreads"; workspaceId: string; threads: ThreadSummary[] }
  | {
      type: "setThreadListLoading";
      workspaceId: string;
      isLoading: boolean;
    }
  | {
      type: "setThreadListPaging";
      workspaceId: string;
      isLoading: boolean;
    }
  | {
      type: "setThreadListCursor";
      workspaceId: string;
      cursor: string | null;
    }
  | { type: "addApproval"; approval: ApprovalRequest }
  | { type: "removeApproval"; requestId: number | string; workspaceId: string }
  | { type: "addUserInputRequest"; request: RequestUserInputRequest }
  | {
      type: "removeUserInputRequest";
      requestId: number | string;
      workspaceId: string;
    }
  | {
      type: "clearUserInputRequestsForThread";
      workspaceId: string;
      threadId: string;
    }
  | { type: "setThreadTokenUsage"; threadId: string; tokenUsage: ThreadTokenUsage }
  | {
      type: "setRateLimits";
      workspaceId: string;
      rateLimits: RateLimitSnapshot | null;
    }
  | {
      type: "setAccountInfo";
      workspaceId: string;
      account: AccountSnapshot | null;
    }
  | { type: "setActiveTurnId"; threadId: string; turnId: string | null }
  | { type: "setThreadPlan"; threadId: string; plan: TurnPlan | null }
  | { type: "clearThreadPlan"; threadId: string }
  | { type: "incrementAgentSegment"; threadId: string }
  | { type: "resetAgentSegment"; threadId: string }
  | {
      type: "setLastAgentMessage";
      threadId: string;
      text: string;
      timestamp: number;
    }
  | {
      type: "renameThreadId";
      workspaceId: string;
      oldThreadId: string;
      newThreadId: string;
    };

const emptyItems: Record<string, ConversationItem[]> = {};

export const initialState: ThreadState = {
  activeThreadIdByWorkspace: {},
  itemsByThread: emptyItems,
  threadsByWorkspace: {},
  hiddenThreadIdsByWorkspace: {},
  threadParentById: {},
  threadStatusById: {},
  threadListLoadingByWorkspace: {},
  threadListPagingByWorkspace: {},
  threadListCursorByWorkspace: {},
  activeTurnIdByThread: {},
  approvals: [],
  userInputRequests: [],
  tokenUsageByThread: {},
  rateLimitsByWorkspace: {},
  accountByWorkspace: {},
  planByThread: {},
  lastAgentMessageByThread: {},
  agentSegmentByThread: {},
};

function mergeStreamingText(existing: string, delta: string) {
  if (!delta) {
    return existing;
  }
  if (!existing) {
    return delta;
  }
  if (delta === existing) {
    return existing;
  }
  if (delta.startsWith(existing)) {
    return delta;
  }
  if (existing.startsWith(delta)) {
    return existing;
  }
  const maxOverlap = Math.min(existing.length, delta.length);
  for (let length = maxOverlap; length > 0; length -= 1) {
    if (existing.endsWith(delta.slice(0, length))) {
      return `${existing}${delta.slice(length)}`;
    }
  }
  return `${existing}${delta}`;
}

const REASONING_BOUNDARY_MIN_TRAILING_CHARS = 6;
const REASONING_BOUNDARY_PUNCTUATION_REGEX = /[。！？!?;；:：]$/;
const REASONING_FRAGMENT_MIN_RUN = 5;
const REASONING_FRAGMENT_MAX_LENGTH = 14;
const REASONING_FRAGMENT_MIN_TOTAL_CHARS = 12;
const REASONING_FRAGMENT_EDGE_MIN_LENGTH = 6;
const PARAGRAPH_BREAK_SPLIT_REGEX = /\r?\n[^\S\r\n]*\r?\n+/;

function hasParagraphBreak(value: string) {
  return PARAGRAPH_BREAK_SPLIT_REGEX.test(value);
}

function shouldMergeReasoningFragment(value: string) {
  const trimmed = value.trim();
  return (
    trimmed.length > 0 &&
    trimmed.length <= REASONING_FRAGMENT_MAX_LENGTH &&
    !looksLikeMarkdownBlockStart(trimmed)
  );
}

function joinReasoningFragments(segments: string[]) {
  return segments.reduce((combined, segment) => {
    if (!segment) {
      return combined;
    }
    if (!combined) {
      return segment;
    }
    const previousChar = combined[combined.length - 1] ?? "";
    const nextChar = segment[0] ?? "";
    const shouldInsertSpace =
      /[A-Za-z0-9]/.test(previousChar) && /[A-Za-z0-9]/.test(nextChar);
    return shouldInsertSpace ? `${combined} ${segment}` : `${combined}${segment}`;
  }, "");
}

function extractReasoningBlockquoteText(paragraph: string) {
  const lines = paragraph.split(/\r?\n/);
  const fragments: string[] = [];
  for (const line of lines) {
    if (!line.trim()) {
      continue;
    }
    const match = line.match(/^\s*>\s?(.*)$/);
    if (!match) {
      return null;
    }
    const content = match[1].trim();
    if (!content || looksLikeMarkdownBlockStart(content)) {
      return null;
    }
    fragments.push(content);
  }
  if (fragments.length === 0) {
    return null;
  }
  return joinReasoningFragments(fragments);
}

function trimReasoningMergeWindow(
  entries: string[],
  start: number,
  end: number,
) {
  let mergeStart = start;
  let mergeEnd = end;
  while (mergeStart < mergeEnd) {
    const edge = entries[mergeStart] ?? "";
    if (
      edge.length >= REASONING_FRAGMENT_EDGE_MIN_LENGTH &&
      REASONING_BOUNDARY_PUNCTUATION_REGEX.test(edge.trim())
    ) {
      mergeStart += 1;
      continue;
    }
    break;
  }
  while (mergeEnd > mergeStart) {
    const edge = entries[mergeEnd - 1] ?? "";
    if (
      edge.length >= REASONING_FRAGMENT_EDGE_MIN_LENGTH &&
      REASONING_BOUNDARY_PUNCTUATION_REGEX.test(edge.trim())
    ) {
      mergeEnd -= 1;
      continue;
    }
    break;
  }
  return { mergeStart, mergeEnd };
}

function normalizeReasoningFragmentedParagraphs(value: string) {
  if (!hasParagraphBreak(value) || value.includes("```")) {
    return value;
  }
  const paragraphs = value.split(PARAGRAPH_BREAK_SPLIT_REGEX);
  if (paragraphs.length < REASONING_FRAGMENT_MIN_RUN) {
    return value;
  }
  const trimmedParagraphs = paragraphs.map((entry) => entry.trim());

  const normalized: string[] = [];
  let changed = false;
  let index = 0;
  while (index < paragraphs.length) {
    const current = paragraphs[index] ?? "";
    const currentQuoteText = extractReasoningBlockquoteText(current);
    if (
      currentQuoteText &&
      shouldMergeReasoningFragment(currentQuoteText)
    ) {
      let cursor = index;
      const quoteEntries: string[] = [];
      while (cursor < paragraphs.length) {
        const candidateQuoteText = extractReasoningBlockquoteText(paragraphs[cursor] ?? "");
        if (
          !candidateQuoteText ||
          !shouldMergeReasoningFragment(candidateQuoteText)
        ) {
          break;
        }
        quoteEntries.push(candidateQuoteText.trim());
        cursor += 1;
      }

      const { mergeStart, mergeEnd } = trimReasoningMergeWindow(
        quoteEntries,
        0,
        quoteEntries.length,
      );
      if (mergeStart > 0) {
        normalized.push(...quoteEntries.slice(0, mergeStart).map((entry) => `> ${entry}`));
      }
      const mergeCandidates = quoteEntries.slice(mergeStart, mergeEnd);
      const mergeTotalChars = mergeCandidates.reduce((sum, entry) => sum + entry.length, 0);
      if (
        mergeCandidates.length >= REASONING_FRAGMENT_MIN_RUN &&
        mergeTotalChars >= REASONING_FRAGMENT_MIN_TOTAL_CHARS
      ) {
        normalized.push(`> ${joinReasoningFragments(mergeCandidates)}`);
        changed = true;
      } else {
        normalized.push(...mergeCandidates.map((entry) => `> ${entry}`));
      }
      if (mergeEnd < quoteEntries.length) {
        normalized.push(...quoteEntries.slice(mergeEnd).map((entry) => `> ${entry}`));
      }
      index = cursor;
      continue;
    }

    if (!shouldMergeReasoningFragment(current)) {
      normalized.push(current);
      index += 1;
      continue;
    }

    let cursor = index;
    while (cursor < paragraphs.length) {
      const candidate = paragraphs[cursor] ?? "";
      if (!shouldMergeReasoningFragment(candidate)) {
        break;
      }
      cursor += 1;
    }

    const { mergeStart, mergeEnd } = trimReasoningMergeWindow(
      trimmedParagraphs,
      index,
      cursor,
    );

    if (mergeStart > index) {
      normalized.push(...paragraphs.slice(index, mergeStart));
    }

    const mergeCandidates = trimmedParagraphs.slice(mergeStart, mergeEnd).filter(Boolean);
    const mergeTotalChars = mergeCandidates.reduce((sum, entry) => sum + entry.length, 0);
    if (
      mergeCandidates.length >= REASONING_FRAGMENT_MIN_RUN &&
      mergeTotalChars >= REASONING_FRAGMENT_MIN_TOTAL_CHARS
    ) {
      normalized.push(joinReasoningFragments(mergeCandidates));
      changed = true;
    } else {
      normalized.push(...paragraphs.slice(mergeStart, mergeEnd));
    }

    if (mergeEnd < cursor) {
      normalized.push(...paragraphs.slice(mergeEnd, cursor));
    }
    index = cursor;
  }
  return changed ? normalized.join("\n\n") : value;
}

function dedupeReasoningParagraphs(value: string) {
  if (!value) {
    return value;
  }
  const paragraphs = value
    .split(PARAGRAPH_BREAK_SPLIT_REGEX)
    .map((entry) => entry.trim())
    .filter(Boolean);
  if (paragraphs.length <= 1) {
    return value;
  }
  const deduped: string[] = [];
  for (const paragraph of paragraphs) {
    const previous = deduped[deduped.length - 1];
    if (
      previous &&
      compactStreamingText(previous) === compactStreamingText(paragraph) &&
      compactStreamingText(paragraph).length >= 8
    ) {
      continue;
    }
    deduped.push(paragraph);
  }
  return deduped.join("\n\n");
}

function dedupeRepeatedReasoningSentences(value: string) {
  if (!value) {
    return value;
  }
  const sliceByCompactLength = (text: string, targetCompactLength: number) => {
    let compactLength = 0;
    for (let index = 0; index < text.length; index += 1) {
      if (!/\s/.test(text[index])) {
        compactLength += 1;
      }
      if (compactLength >= targetCompactLength) {
        return text.slice(0, index + 1).trim();
      }
    }
    return text.trim();
  };

  const collapseRepeatedParagraph = (paragraph: string) => {
    const trimmed = paragraph.trim();
    if (trimmed.length < 12) {
      return trimmed;
    }
    const directRepeat = trimmed.match(/^([\s\S]{6,}?)\s+\1$/);
    if (directRepeat?.[1]) {
      return directRepeat[1].trim();
    }
    const compact = compactStreamingText(trimmed);
    if (compact.length >= 12 && compact.length % 2 === 0) {
      const halfLength = compact.length / 2;
      const half = compact.slice(0, halfLength);
      if (`${half}${half}` === compact) {
        return sliceByCompactLength(trimmed, halfLength);
      }
    }
    const sentenceMatches = trimmed.match(/[^。！？!?]+[。！？!?]/g);
    if (sentenceMatches && sentenceMatches.length >= 4 && sentenceMatches.length % 2 === 0) {
      const half = sentenceMatches.length / 2;
      const leftCompact = compactStreamingText(sentenceMatches.slice(0, half).join(""));
      const rightCompact = compactStreamingText(sentenceMatches.slice(half).join(""));
      if (leftCompact.length >= 6 && leftCompact === rightCompact) {
        return sentenceMatches.slice(0, half).join("").trim();
      }
    }
    return trimmed;
  };

  const dedupeParagraph = (paragraph: string) => {
    const collapsed = collapseRepeatedParagraph(paragraph);
    const sentenceMatches = collapsed.match(/[^。！？!?]+[。！？!?]/g);
    if (!sentenceMatches || sentenceMatches.length < 2) {
      return collapsed;
    }
    const deduped: string[] = [];
    for (const sentence of sentenceMatches) {
      const trimmed = sentence.trim();
      const previous = deduped[deduped.length - 1];
      if (
        previous &&
        compactStreamingText(previous) === compactStreamingText(trimmed) &&
        compactStreamingText(trimmed).length >= 6
      ) {
        continue;
      }
      deduped.push(trimmed);
    }
    const remainder = collapsed.slice(sentenceMatches.join("").length);
    return `${deduped.join("")}${remainder}`.trim();
  };

  if (!hasParagraphBreak(value)) {
    return dedupeParagraph(value);
  }
  return value
    .split(PARAGRAPH_BREAK_SPLIT_REGEX)
    .map((entry) => dedupeParagraph(entry.trim()))
    .filter(Boolean)
    .join("\n\n");
}

function normalizeReasoningReadableText(value: string) {
  const compacted = normalizeReasoningFragmentedParagraphs(value);
  return dedupeRepeatedReasoningSentences(dedupeReasoningParagraphs(compacted));
}

function trailingSummaryFragment(value: string) {
  const fragments = value
    .split(PARAGRAPH_BREAK_SPLIT_REGEX)
    .map((entry) => entry.trim())
    .filter(Boolean);
  return fragments.length > 0 ? fragments[fragments.length - 1] : "";
}

function compactStreamingText(value: string) {
  return value.replace(/\s+/g, "");
}

function compactComparableStreamingText(value: string) {
  return compactStreamingText(value)
    .replace(/[！!]/g, "!")
    .replace(/[？?]/g, "?")
    .replace(/[，,]/g, ",")
    .replace(/[。．.]/g, ".");
}

function sharedPrefixLength(left: string, right: string) {
  const max = Math.min(left.length, right.length);
  let index = 0;
  while (index < max && left[index] === right[index]) {
    index += 1;
  }
  return index;
}

function tailAnchor(value: string) {
  if (!value) {
    return "";
  }
  const anchorLength = Math.min(24, Math.max(8, Math.floor(value.length * 0.3)));
  return value.slice(-anchorLength);
}

function sliceByCompactStreamingLength(value: string, compactLength: number) {
  if (compactLength <= 0) {
    return value;
  }
  let count = 0;
  for (let index = 0; index < value.length; index += 1) {
    if (!/\s/.test(value[index])) {
      count += 1;
    }
    if (count >= compactLength) {
      return value.slice(index + 1);
    }
  }
  return "";
}

function scoreParagraphFragmentation(value: string) {
  const segments = value
    .split(PARAGRAPH_BREAK_SPLIT_REGEX)
    .map((entry) => entry.trim())
    .filter(Boolean);
  if (segments.length <= 1) {
    return 0;
  }
  const shortSegments = segments.filter((entry) => entry.length <= 8).length;
  return shortSegments * 3 + segments.length;
}

function chooseReadableText(existing: string, incoming: string) {
  const existingScore = scoreParagraphFragmentation(existing);
  const incomingScore = scoreParagraphFragmentation(incoming);
  if (incomingScore < existingScore) {
    return incoming;
  }
  if (existingScore < incomingScore) {
    return existing;
  }
  return incoming.length >= existing.length ? incoming : existing;
}

function looksLikeMarkdownBlockStart(value: string) {
  const trimmed = value.trimStart();
  return (
    /^[-*+]\s/.test(trimmed) ||
    /^\d+\.\s/.test(trimmed) ||
    /^>\s?/.test(trimmed) ||
    /^#{1,6}\s/.test(trimmed) ||
    /^```/.test(trimmed) ||
    /^\|/.test(trimmed)
  );
}

function sanitizeTinyLeadingBreakDelta(existing: string, delta: string) {
  if (!existing || !delta.startsWith("\n\n")) {
    return delta;
  }
  const withoutLeadingBreaks = delta.replace(/^\n{2,}/, "");
  if (!withoutLeadingBreaks) {
    return delta;
  }
  const trimmed = withoutLeadingBreaks.trim();
  if (
    trimmed.length === 0 ||
    trimmed.length > 20 ||
    looksLikeMarkdownBlockStart(withoutLeadingBreaks)
  ) {
    return delta;
  }
  const previousChar = existing.trimEnd().slice(-1);
  if (!previousChar || /[\n。！？!?;；:：]/.test(previousChar)) {
    return delta;
  }
  return withoutLeadingBreaks;
}

function stripLeadingEchoFromSnapshot(existing: string, candidate: string) {
  if (!existing || !candidate || !candidate.startsWith(existing)) {
    return candidate;
  }
  const compactExisting = compactStreamingText(existing);
  if (compactExisting.length < 12) {
    return candidate;
  }
  let current = candidate;
  for (let attempt = 0; attempt < 2; attempt += 1) {
    if (!current.startsWith(existing)) {
      break;
    }
    const suffix = current.slice(existing.length);
    const trimmedSuffix = suffix.trimStart();
    if (!trimmedSuffix) {
      return existing;
    }
    const compactSuffix = compactStreamingText(trimmedSuffix);
    if (!compactSuffix.startsWith(compactExisting)) {
      break;
    }
    const tail = sliceByCompactStreamingLength(trimmedSuffix, compactExisting.length);
    if (!tail.trim()) {
      return existing;
    }
    current = `${existing}${tail}`;
  }
  return current;
}

function mergeAgentMessageText(existing: string, delta: string) {
  const normalizedDelta = stripLeadingEchoFromSnapshot(
    existing,
    sanitizeTinyLeadingBreakDelta(existing, delta),
  );
  if (!normalizedDelta) {
    return existing;
  }
  if (!existing) {
    return normalizedDelta;
  }
  const compactExisting = compactComparableStreamingText(existing);
  const compactDelta = compactComparableStreamingText(normalizedDelta);
  if (compactExisting && compactDelta) {
    if (compactDelta === compactExisting) {
      return chooseReadableText(existing, normalizedDelta);
    }
    if (compactDelta.startsWith(compactExisting) && normalizedDelta.length >= existing.length) {
      return normalizedDelta;
    }
    if (compactExisting.startsWith(compactDelta) && existing.length >= normalizedDelta.length) {
      return existing;
    }
    if (compactDelta.includes(compactExisting) && normalizedDelta.length >= existing.length * 0.8) {
      const firstIndex = compactDelta.indexOf(compactExisting);
      const secondIndex = compactDelta.indexOf(
        compactExisting,
        firstIndex + Math.max(1, Math.floor(compactExisting.length / 2)),
      );
      if (firstIndex > 0 || secondIndex >= 0) {
        return chooseReadableText(existing, normalizedDelta);
      }
      return normalizedDelta;
    }
    const minComparableLength = Math.min(compactDelta.length, compactExisting.length);
    if (minComparableLength >= 24) {
      const sharedComparablePrefix = sharedPrefixLength(compactExisting, compactDelta);
      if (sharedComparablePrefix >= Math.floor(minComparableLength * 0.72)) {
        return chooseReadableText(existing, normalizedDelta);
      }
      const existingTailAnchor = tailAnchor(compactExisting);
      if (
        sharedComparablePrefix >= 12 &&
        existingTailAnchor.length >= 8 &&
        compactDelta.includes(existingTailAnchor)
      ) {
        return chooseReadableText(existing, normalizedDelta);
      }
    }
  }
  return mergeStreamingText(existing, normalizedDelta);
}

function mergeReasoningText(existing: string, delta: string) {
  return normalizeReasoningReadableText(mergeAgentMessageText(existing, delta));
}

function mergeCompletedAgentText(existing: string, completed: string) {
  const normalizedCompleted = normalizeCompletedAssistantText(completed);
  if (!normalizedCompleted) {
    return existing;
  }
  if (!existing) {
    return normalizedCompleted;
  }
  const compactExisting = compactStreamingText(existing);
  const compactCompleted = compactStreamingText(normalizedCompleted);
  if (!compactExisting || !compactCompleted) {
    return normalizedCompleted;
  }

  if (compactCompleted === compactExisting) {
    return chooseReadableText(existing, normalizedCompleted);
  }

  const comparableExisting = compactComparableStreamingText(existing);
  const comparableCompleted = compactComparableStreamingText(normalizedCompleted);
  if (comparableExisting && comparableCompleted) {
    const comparableLengthDelta = Math.abs(
      comparableCompleted.length - comparableExisting.length,
    );
    const sharedComparablePrefix = sharedPrefixLength(
      comparableExisting,
      comparableCompleted,
    );
    if (
      Math.min(comparableExisting.length, comparableCompleted.length) >= 24 &&
      comparableLengthDelta <= 6 &&
      sharedComparablePrefix >= 6
    ) {
      const existingTailAnchor = tailAnchor(comparableExisting);
      const completedTailAnchor = tailAnchor(comparableCompleted);
      if (
        existingTailAnchor.length >= 8 &&
        completedTailAnchor.length >= 8 &&
        comparableCompleted.includes(existingTailAnchor) &&
        comparableExisting.includes(completedTailAnchor)
      ) {
        return chooseReadableText(existing, normalizedCompleted);
      }
    }
  }

  const repeatedFromStart =
    compactCompleted.startsWith(compactExisting) &&
    compactCompleted.endsWith(compactExisting) &&
    compactCompleted.length > compactExisting.length &&
    compactCompleted.indexOf(compactExisting, 1) >= compactExisting.length;
  if (
    repeatedFromStart &&
    scoreParagraphFragmentation(normalizedCompleted) > scoreParagraphFragmentation(existing)
  ) {
    return existing;
  }

  return normalizeCompletedAssistantText(mergeAgentMessageText(existing, normalizedCompleted));
}

function normalizeCompletedAssistantText(value: string) {
  const normalizedMessage = normalizeItem({
    id: "__completed-assistant-normalization__",
    kind: "message",
    role: "assistant",
    text: value,
  });
  const normalizedByItem =
    normalizedMessage.kind === "message" ? normalizedMessage.text : value;
  if (normalizedByItem && normalizedByItem !== value) {
    return normalizedByItem;
  }

  const trimmed = value.trim();
  if (!trimmed) {
    return value;
  }

  // 非 markdown 普通文本里，偶发会收到 "A + 空白 + A" 的重复 completed payload。
  // 这里优先压缩为单份，避免最终气泡出现整段重复拼接。
  if (!/```/.test(trimmed) && !looksLikeMarkdownBlockStart(trimmed)) {
    const directRepeat = trimmed.match(/^([\s\S]{12,}?)\s+\1$/);
    if (directRepeat?.[1]) {
      return directRepeat[1].trim();
    }
  }

  return value;
}

function findAssistantMessageIndexById(
  list: ConversationItem[],
  candidateId: string,
) {
  if (!candidateId) {
    return -1;
  }
  for (let index = list.length - 1; index >= 0; index -= 1) {
    const item = list[index];
    if (
      item.kind === "message" &&
      item.role === "assistant" &&
      item.id === candidateId
    ) {
      return index;
    }
  }
  return -1;
}

function findAssistantMessageIndexByPrefix(
  list: ConversationItem[],
  idPrefix: string,
) {
  if (!idPrefix) {
    return -1;
  }
  const segmentPrefix = `${idPrefix}-seg-`;
  for (let index = list.length - 1; index >= 0; index -= 1) {
    const item = list[index];
    if (
      item.kind === "message" &&
      item.role === "assistant" &&
      item.id.startsWith(segmentPrefix)
    ) {
      return index;
    }
  }
  return -1;
}

function addSummaryBoundary(existing: string) {
  if (!existing) {
    return existing;
  }
  const trailingFragment = trailingSummaryFragment(existing);
  if (!trailingFragment) {
    return existing;
  }
  if (
    trailingFragment.length < REASONING_BOUNDARY_MIN_TRAILING_CHARS &&
    !REASONING_BOUNDARY_PUNCTUATION_REGEX.test(trailingFragment)
  ) {
    return existing;
  }
  if (existing.endsWith("\n\n")) {
    return existing;
  }
  if (existing.endsWith("\n")) {
    return `${existing}\n`;
  }
  return `${existing}\n\n`;
}

function dropLatestLocalReviewStart(list: ConversationItem[]) {
  for (let index = list.length - 1; index >= 0; index -= 1) {
    const item = list[index];
    if (
      item.kind === "review" &&
      item.state === "started" &&
      item.id.startsWith("review-start-")
    ) {
      return [...list.slice(0, index), ...list.slice(index + 1)];
    }
  }
  return list;
}

function findMatchingReview(
  list: ConversationItem[],
  target: Extract<ConversationItem, { kind: "review" }>,
) {
  const normalizedText = target.text.trim();
  return list.find(
    (item) =>
      item.kind === "review" &&
      item.state === target.state &&
      item.text.trim() === normalizedText,
  );
}

function ensureUniqueReviewId(list: ConversationItem[], item: ConversationItem) {
  if (item.kind !== "review") {
    return item;
  }
  if (!list.some((entry) => entry.id === item.id)) {
    return item;
  }
  const existingIds = new Set(list.map((entry) => entry.id));
  let suffix = 1;
  let candidate = `${item.id}-${suffix}`;
  while (existingIds.has(candidate)) {
    suffix += 1;
    candidate = `${item.id}-${suffix}`;
  }
  return { ...item, id: candidate };
}

function isDuplicateReviewById(
  list: ConversationItem[],
  target: Extract<ConversationItem, { kind: "review" }>,
) {
  const normalizedText = target.text.trim();
  return list.some(
    (item) =>
      item.kind === "review" &&
      item.id === target.id &&
      item.state === target.state &&
      item.text.trim() === normalizedText,
  );
}

export function threadReducer(state: ThreadState, action: ThreadAction): ThreadState {
  switch (action.type) {
    case "setActiveThreadId":
      return {
        ...state,
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]: action.threadId,
        },
        threadStatusById: action.threadId
          ? {
              ...state.threadStatusById,
              [action.threadId]: {
                isProcessing:
                  state.threadStatusById[action.threadId]?.isProcessing ?? false,
                hasUnread: false,
                isReviewing:
                  state.threadStatusById[action.threadId]?.isReviewing ?? false,
                processingStartedAt:
                  state.threadStatusById[action.threadId]?.processingStartedAt ??
                  null,
                lastDurationMs:
                  state.threadStatusById[action.threadId]?.lastDurationMs ?? null,
                heartbeatPulse:
                  state.threadStatusById[action.threadId]?.heartbeatPulse ?? 0,
              },
            }
          : state.threadStatusById,
      };
    case "ensureThread": {
      const hidden =
        state.hiddenThreadIdsByWorkspace[action.workspaceId]?.[action.threadId] ??
        false;
      if (hidden) {
        return state;
      }
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      let existingIndex = list.findIndex((thread) => thread.id === action.threadId);
      if (existingIndex < 0 && !action.threadId.includes(":")) {
        const aliasIndexes = list
          .map((thread, index) => ({ thread, index }))
          .filter(({ thread }) => thread.id.endsWith(`:${action.threadId}`))
          .map(({ index }) => index);
        if (aliasIndexes.length === 1) {
          existingIndex = aliasIndexes[0];
        }
      }
      if (existingIndex >= 0) {
        const existing = list[existingIndex];
        // BUG FIX: Only update engineSource if action.engine is explicitly provided
        // AND the existing engineSource is not already set.
        // This prevents inferred engines (from inferEngineFromThreadId) from
        // overwriting explicitly set engines.
        if (!action.engine || existing.engineSource) {
          return state;
        }
        const updated = { ...existing, engineSource: action.engine };
        const nextList = [...list];
        nextList[existingIndex] = updated;
        return {
          ...state,
          threadsByWorkspace: {
            ...state.threadsByWorkspace,
            [action.workspaceId]: nextList,
          },
        };
      }

      // CRITICAL FIX: Handle race condition between renameThreadId and subsequent events.
      // If threadId is engine:{sessionId} but not found, check for pending thread to rename.
      const pendingPrefix = action.threadId.startsWith("claude:")
        ? "claude-pending-"
        : action.threadId.startsWith("opencode:")
          ? "opencode-pending-"
          : null;
      if (pendingPrefix) {
        const pendingIndexes: number[] = [];
        list.forEach((thread, index) => {
          if (thread.id.startsWith(pendingPrefix)) {
            pendingIndexes.push(index);
          }
        });

        const hasPendingThreadActivity = (threadId: string) =>
          Boolean(state.threadStatusById[threadId]?.isProcessing) ||
          (state.activeTurnIdByThread[threadId] ?? null) !== null ||
          (state.itemsByThread[threadId]?.length ?? 0) > 0 ||
          Boolean(state.lastAgentMessageByThread[threadId]);

        // Prefer deterministic reconciliation when multiple pending threads exist:
        // 1) single processing pending thread
        // 2) single pending thread with an active turn id
        // 3) single pending thread with observed activity (messages/deltas)
        let pendingIndex: number | null = null;
        if (pendingIndexes.length === 1) {
          const singlePendingId = list[pendingIndexes[0]]?.id ?? "";
          if (singlePendingId && hasPendingThreadActivity(singlePendingId)) {
            pendingIndex = pendingIndexes[0];
          }
        } else if (pendingIndexes.length > 1) {
          const processingIndexes = pendingIndexes.filter((index) => {
            const pendingId = list[index]?.id;
            return pendingId
              ? Boolean(state.threadStatusById[pendingId]?.isProcessing)
              : false;
          });
          if (processingIndexes.length === 1) {
            pendingIndex = processingIndexes[0];
          }

          if (pendingIndex === null) {
            const turnBoundIndexes = pendingIndexes.filter((index) => {
              const pendingId = list[index]?.id;
              return pendingId
                ? (state.activeTurnIdByThread[pendingId] ?? null) !== null
                : false;
            });
            if (turnBoundIndexes.length === 1) {
              pendingIndex = turnBoundIndexes[0];
            }
          }

          if (pendingIndex === null) {
            const activityIndexes = pendingIndexes.filter((index) => {
              const pendingId = list[index]?.id;
              return pendingId ? hasPendingThreadActivity(pendingId) : false;
            });
            if (activityIndexes.length === 1) {
              pendingIndex = activityIndexes[0];
            }
          }
        }

        if (pendingIndex !== null) {
          // Found a pending thread - perform inline rename to avoid race condition
          const pendingThread = list[pendingIndex];
          const oldThreadId = pendingThread.id;
          const newThreadId = action.threadId;

          // Rename thread inline (similar to renameThreadId action)
          const updatedThread = { ...pendingThread, id: newThreadId };
          const nextList = [...list];
          nextList[pendingIndex] = updatedThread;

          // Update all related state maps
          const newItemsByThread = { ...state.itemsByThread };
          if (newItemsByThread[oldThreadId]) {
            newItemsByThread[newThreadId] = newItemsByThread[oldThreadId];
            delete newItemsByThread[oldThreadId];
          }

          const newThreadStatusById = { ...state.threadStatusById };
          if (newThreadStatusById[oldThreadId]) {
            newThreadStatusById[newThreadId] = newThreadStatusById[oldThreadId];
            delete newThreadStatusById[oldThreadId];
          }

          const newActiveTurnIdByThread = { ...state.activeTurnIdByThread };
          if (newActiveTurnIdByThread[oldThreadId] !== undefined) {
            newActiveTurnIdByThread[newThreadId] = newActiveTurnIdByThread[oldThreadId];
            delete newActiveTurnIdByThread[oldThreadId];
          }

          const newActiveThreadIdByWorkspace = { ...state.activeThreadIdByWorkspace };
          if (newActiveThreadIdByWorkspace[action.workspaceId] === oldThreadId) {
            newActiveThreadIdByWorkspace[action.workspaceId] = newThreadId;
          }

          const newTokenUsageByThread = { ...state.tokenUsageByThread };
          if (newTokenUsageByThread[oldThreadId]) {
            newTokenUsageByThread[newThreadId] = newTokenUsageByThread[oldThreadId];
            delete newTokenUsageByThread[oldThreadId];
          }

          const newPlanByThread = { ...state.planByThread };
          if (newPlanByThread[oldThreadId] !== undefined) {
            newPlanByThread[newThreadId] = newPlanByThread[oldThreadId];
            delete newPlanByThread[oldThreadId];
          }

          const newLastAgentMessageByThread = { ...state.lastAgentMessageByThread };
          if (newLastAgentMessageByThread[oldThreadId]) {
            newLastAgentMessageByThread[newThreadId] = newLastAgentMessageByThread[oldThreadId];
            delete newLastAgentMessageByThread[oldThreadId];
          }

          const newAgentSegmentByThread = { ...state.agentSegmentByThread };
          if (newAgentSegmentByThread[oldThreadId] !== undefined) {
            newAgentSegmentByThread[newThreadId] = newAgentSegmentByThread[oldThreadId];
            delete newAgentSegmentByThread[oldThreadId];
          }

          const newThreadParentById = { ...state.threadParentById };
          if (newThreadParentById[oldThreadId]) {
            newThreadParentById[newThreadId] = newThreadParentById[oldThreadId];
            delete newThreadParentById[oldThreadId];
          }
          for (const [threadId, parentId] of Object.entries(newThreadParentById)) {
            if (parentId === oldThreadId) {
              newThreadParentById[threadId] = newThreadId;
            }
          }

          return {
            ...state,
            threadsByWorkspace: {
              ...state.threadsByWorkspace,
              [action.workspaceId]: nextList,
            },
            itemsByThread: newItemsByThread,
            threadStatusById: newThreadStatusById,
            activeTurnIdByThread: newActiveTurnIdByThread,
            activeThreadIdByWorkspace: newActiveThreadIdByWorkspace,
            tokenUsageByThread: newTokenUsageByThread,
            planByThread: newPlanByThread,
            lastAgentMessageByThread: newLastAgentMessageByThread,
            agentSegmentByThread: newAgentSegmentByThread,
            threadParentById: newThreadParentById,
          };
        }
      }

      // No existing thread and no pending thread to rename - create new thread
      const thread: ThreadSummary = {
        id: action.threadId,
        name: `Agent ${list.length + 1}`,
        updatedAt: 0,
        engineSource: action.engine,
      };
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: [thread, ...list],
        },
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: {
            isProcessing: false,
            hasUnread: false,
            isReviewing: false,
            processingStartedAt: null,
            lastDurationMs: null,
            heartbeatPulse: 0,
          },
        },
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]:
            state.activeThreadIdByWorkspace[action.workspaceId] ?? action.threadId,
        },
      };
    }
    case "hideThread": {
      const hiddenForWorkspace =
        state.hiddenThreadIdsByWorkspace[action.workspaceId] ?? {};
      if (hiddenForWorkspace[action.threadId]) {
        return state;
      }

      const nextHiddenForWorkspace = {
        ...hiddenForWorkspace,
        [action.threadId]: true as const,
      };

      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const filtered = list.filter((thread) => thread.id !== action.threadId);
      const nextActive =
        state.activeThreadIdByWorkspace[action.workspaceId] === action.threadId
          ? filtered[0]?.id ?? null
          : state.activeThreadIdByWorkspace[action.workspaceId] ?? null;

      return {
        ...state,
        hiddenThreadIdsByWorkspace: {
          ...state.hiddenThreadIdsByWorkspace,
          [action.workspaceId]: nextHiddenForWorkspace,
        },
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: filtered,
        },
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]: nextActive,
        },
      };
    }
    case "removeThread": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const filtered = list.filter((thread) => thread.id !== action.threadId);
      const nextActive =
        state.activeThreadIdByWorkspace[action.workspaceId] === action.threadId
          ? filtered[0]?.id ?? null
          : state.activeThreadIdByWorkspace[action.workspaceId] ?? null;
      const { [action.threadId]: _items, ...restItems } = state.itemsByThread;
      const { [action.threadId]: _status, ...restStatus } = state.threadStatusById;
      const { [action.threadId]: _turns, ...restTurns } = state.activeTurnIdByThread;
      const { [action.threadId]: _plans, ...restPlans } = state.planByThread;
      const { [action.threadId]: _parents, ...restParents } = state.threadParentById;
      const { [action.threadId]: _tokenUsage, ...restTokenUsage } = state.tokenUsageByThread;
      const { [action.threadId]: _lastAgent, ...restLastAgent } = state.lastAgentMessageByThread;
      const { [action.threadId]: _segments, ...restSegments } = state.agentSegmentByThread;
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: filtered,
        },
        itemsByThread: restItems,
        threadStatusById: restStatus,
        activeTurnIdByThread: restTurns,
        planByThread: restPlans,
        threadParentById: restParents,
        tokenUsageByThread: restTokenUsage,
        lastAgentMessageByThread: restLastAgent,
        agentSegmentByThread: restSegments,
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]: nextActive,
        },
      };
    }
    case "setThreadParent": {
      if (!action.parentId || action.parentId === action.threadId) {
        return state;
      }
      if (state.threadParentById[action.threadId] === action.parentId) {
        return state;
      }
      return {
        ...state,
        threadParentById: {
          ...state.threadParentById,
          [action.threadId]: action.parentId,
        },
      };
    }
    case "markProcessing": {
      const previous = state.threadStatusById[action.threadId];
      const wasProcessing = previous?.isProcessing ?? false;
      const startedAt = previous?.processingStartedAt ?? null;
      const lastDurationMs = previous?.lastDurationMs ?? null;
      const heartbeatPulse = previous?.heartbeatPulse ?? 0;
      if (action.isProcessing) {
        return {
          ...state,
          threadStatusById: {
            ...state.threadStatusById,
            [action.threadId]: {
              isProcessing: true,
              hasUnread: previous?.hasUnread ?? false,
              isReviewing: previous?.isReviewing ?? false,
              processingStartedAt:
                wasProcessing && startedAt ? startedAt : action.timestamp,
              lastDurationMs,
              heartbeatPulse: wasProcessing ? heartbeatPulse : 0,
            },
          },
        };
      }
      const nextDuration =
        wasProcessing && startedAt
          ? Math.max(0, action.timestamp - startedAt)
          : lastDurationMs ?? null;
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: {
            isProcessing: false,
            hasUnread: previous?.hasUnread ?? false,
            isReviewing: previous?.isReviewing ?? false,
            processingStartedAt: null,
            lastDurationMs: nextDuration,
            heartbeatPulse: 0,
          },
        },
      };
    }
    case "markHeartbeat": {
      const previous = state.threadStatusById[action.threadId];
      if (!previous?.isProcessing) {
        return state;
      }
      if (action.pulse <= 0 || action.pulse <= (previous.heartbeatPulse ?? 0)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: {
            ...previous,
            heartbeatPulse: action.pulse,
          },
        },
      };
    }
    case "finalizePendingToolStatuses": {
      const list = state.itemsByThread[action.threadId] ?? [];
      let didChange = false;

      const nextItems = list.map((item) => {
        if (item.kind !== "tool") {
          return item;
        }

        const normalizedStatus = (item.status ?? "").toLowerCase();
        if (
          isFailedToolStatus(normalizedStatus) ||
          isCompletedToolStatus(normalizedStatus)
        ) {
          return item;
        }

        if (!normalizedStatus || isPendingToolStatus(normalizedStatus)) {
          didChange = true;
          return {
            ...item,
            status: action.status,
          };
        }

        return item;
      });

      if (!didChange) {
        return state;
      }

      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(nextItems),
        },
      };
    }
    case "setActiveTurnId":
      return {
        ...state,
        activeTurnIdByThread: {
          ...state.activeTurnIdByThread,
          [action.threadId]: action.turnId,
        },
      };
    case "markReviewing":
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: {
            isProcessing:
              state.threadStatusById[action.threadId]?.isProcessing ?? false,
            hasUnread: state.threadStatusById[action.threadId]?.hasUnread ?? false,
            isReviewing: action.isReviewing,
            processingStartedAt:
              state.threadStatusById[action.threadId]?.processingStartedAt ?? null,
            lastDurationMs:
              state.threadStatusById[action.threadId]?.lastDurationMs ?? null,
            heartbeatPulse:
              state.threadStatusById[action.threadId]?.heartbeatPulse ?? 0,
          },
        },
      };
    case "markUnread":
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: {
            isProcessing:
              state.threadStatusById[action.threadId]?.isProcessing ?? false,
            hasUnread: action.hasUnread,
            isReviewing:
              state.threadStatusById[action.threadId]?.isReviewing ?? false,
            processingStartedAt:
              state.threadStatusById[action.threadId]?.processingStartedAt ?? null,
            lastDurationMs:
              state.threadStatusById[action.threadId]?.lastDurationMs ?? null,
            heartbeatPulse:
              state.threadStatusById[action.threadId]?.heartbeatPulse ?? 0,
          },
        },
      };
    case "addAssistantMessage": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const message: ConversationItem = {
        id: `${Date.now()}-assistant`,
        kind: "message",
        role: "assistant",
        text: action.text,
      };
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems([...list, message]),
        },
      };
    }
    case "setThreadName": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const next = list.map((thread) =>
        thread.id === action.threadId ? { ...thread, name: action.name } : thread,
      );
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: next,
        },
      };
    }
    case "setThreadEngine": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const next = list.map((thread) =>
        thread.id === action.threadId
          ? { ...thread, engineSource: action.engine }
          : thread,
      );
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: next,
        },
      };
    }
    case "setThreadTimestamp": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      if (!list.length) {
        return state;
      }
      let didChange = false;
      const next = list.map((thread) => {
        if (thread.id !== action.threadId) {
          return thread;
        }
        const current = thread.updatedAt ?? 0;
        if (current >= action.timestamp) {
          return thread;
        }
        didChange = true;
        return { ...thread, updatedAt: action.timestamp };
      });
      if (!didChange) {
        return state;
      }
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: next,
        },
      };
    }
    case "appendAgentDelta": {
      // 使用分段 ID：当 tool item 开始时会增加 segment，确保文本和工具交替显示
      const segment = state.agentSegmentByThread[action.threadId] ?? 0;
      const segmentedItemId = segment > 0 ? `${action.itemId}-seg-${segment}` : action.itemId;

      const list = [...(state.itemsByThread[action.threadId] ?? [])];
      const index = list.findIndex((msg) => msg.id === segmentedItemId);
      if (index >= 0 && list[index].kind === "message") {
        const existing = list[index];
        list[index] = {
          ...existing,
          text: mergeAgentMessageText(existing.text, action.delta),
        };
      } else {
        list.push({
          id: segmentedItemId,
          kind: "message",
          role: "assistant",
          text: action.delta,
        });
      }
      const updatedItems = prepareThreadItems(list);
      const nextThreadsByWorkspace = maybeRenameThreadFromAgent({
        workspaceId: action.workspaceId,
        threadId: action.threadId,
        items: updatedItems,
        itemId: segmentedItemId,
        hasCustomName: action.hasCustomName,
        threadsByWorkspace: state.threadsByWorkspace,
      });
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "completeAgentMessage": {
      const segment = state.agentSegmentByThread[action.threadId] ?? 0;
      const segmentedItemId = segment > 0 ? `${action.itemId}-seg-${segment}` : action.itemId;
      const list = [...(state.itemsByThread[action.threadId] ?? [])];
      let index = findAssistantMessageIndexById(list, segmentedItemId);
      if (index < 0) {
        index = findAssistantMessageIndexById(list, action.itemId);
      }
      if (index < 0) {
        index = findAssistantMessageIndexByPrefix(list, action.itemId);
      }
      const targetItemId = index >= 0 ? list[index].id : segmentedItemId;
      const existingItem = index >= 0 ? list[index] : null;
      if (
        existingItem &&
        existingItem.kind === "message" &&
        existingItem.role === "assistant"
      ) {
        list[index] = {
          ...existingItem,
          text: mergeCompletedAgentText(existingItem.text, action.text),
        };
      } else {
        list.push({
          id: targetItemId,
          kind: "message",
          role: "assistant",
          text: action.text,
        });
      }
      const updatedItems = prepareThreadItems(list);
      const nextThreadsByWorkspace = maybeRenameThreadFromAgent({
        workspaceId: action.workspaceId,
        threadId: action.threadId,
        items: updatedItems,
        itemId: targetItemId,
        hasCustomName: action.hasCustomName,
        threadsByWorkspace: state.threadsByWorkspace,
      });
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "upsertItem": {
      let list = state.itemsByThread[action.threadId] ?? [];
      const item = normalizeItem(action.item);
      const isUserMessage = item.kind === "message" && item.role === "user";
      const hadUserMessage = isUserMessage
        ? list.some((entry) => entry.kind === "message" && entry.role === "user")
        : false;
      const renameText = isUserMessage ? extractRenameText(item.text) : "";
      if (
        item.kind === "review" &&
        item.state === "started" &&
        !item.id.startsWith("review-start-")
      ) {
        list = dropLatestLocalReviewStart(list);
      }
      if (item.kind === "review" && isDuplicateReviewById(list, item)) {
        return state;
      }
      if (item.kind === "review") {
        const existing = findMatchingReview(list, item);
        if (existing && existing.id !== item.id) {
          return state;
        }
      }
      let nextItem = ensureUniqueReviewId(list, item);
      if (nextItem.kind === "reasoning") {
        const existingReasoning = list.find(
          (entry): entry is Extract<ConversationItem, { kind: "reasoning" }> =>
            entry.id === nextItem.id && entry.kind === "reasoning",
        );
        if (existingReasoning) {
          const existingSummary = normalizeReasoningReadableText(existingReasoning.summary);
          const incomingSummary = normalizeReasoningReadableText(nextItem.summary);
          const existingContent = normalizeReasoningReadableText(existingReasoning.content);
          const incomingContent = normalizeReasoningReadableText(nextItem.content);
          nextItem = {
            ...nextItem,
            summary: chooseReadableText(existingSummary, incomingSummary),
            content: chooseReadableText(existingContent, incomingContent),
          };
        } else {
          nextItem = {
            ...nextItem,
            summary: normalizeReasoningReadableText(nextItem.summary),
            content: normalizeReasoningReadableText(nextItem.content),
          };
        }
      }
      const updatedItems = prepareThreadItems(upsertItem(list, nextItem));
      let nextThreadsByWorkspace = state.threadsByWorkspace;
      if (isUserMessage) {
        const threads = state.threadsByWorkspace[action.workspaceId] ?? [];
        const textValue = renameText;
        const updatedThreads = threads.map((thread) => {
          if (thread.id !== action.threadId) {
            return thread;
          }
          const looksAutoGenerated = looksAutoGeneratedThreadName(thread.name);
          const shouldRename =
            !hadUserMessage &&
            textValue.length > 0 &&
            looksAutoGenerated &&
            !action.hasCustomName;
          const nextName = shouldRename ? textValue : thread.name;
          return { ...thread, name: nextName };
        });
        const bumpedThreads = updatedThreads.length
          ? [
              ...updatedThreads.filter((thread) => thread.id === action.threadId),
              ...updatedThreads.filter((thread) => thread.id !== action.threadId),
            ]
          : updatedThreads;
        nextThreadsByWorkspace = {
          ...state.threadsByWorkspace,
          [action.workspaceId]: bumpedThreads,
        };
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "setThreadItems":
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(action.items),
        },
      };
    case "setLastAgentMessage":
      if (
        state.lastAgentMessageByThread[action.threadId]?.timestamp >= action.timestamp
      ) {
        return state;
      }
      return {
        ...state,
        lastAgentMessageByThread: {
          ...state.lastAgentMessageByThread,
          [action.threadId]: { text: action.text, timestamp: action.timestamp },
        },
      };
    case "renameThreadId": {
      const { workspaceId, oldThreadId, newThreadId } = action;
      if (oldThreadId === newThreadId) {
        return state;
      }

      // Update activeThreadIdByWorkspace
      const newActiveThreadIdByWorkspace = { ...state.activeThreadIdByWorkspace };
      if (newActiveThreadIdByWorkspace[workspaceId] === oldThreadId) {
        newActiveThreadIdByWorkspace[workspaceId] = newThreadId;
      }

      // Update itemsByThread
      const newItemsByThread = { ...state.itemsByThread };
      if (newItemsByThread[oldThreadId]) {
        const oldItems = newItemsByThread[oldThreadId] ?? [];
        const existingItems = newItemsByThread[newThreadId] ?? [];
        const oldHasUserMessage = oldItems.some(
          (item) => item.kind === "message" && item.role === "user",
        );
        const existingHasUserMessage = existingItems.some(
          (item) => item.kind === "message" && item.role === "user",
        );
        // If existing thread already has user history, append pending items to the tail
        // so the latest user prompt is not truncated out by MAX_ITEMS_PER_THREAD.
        // If existing thread only has assistant deltas (rename race), keep user-first order.
        const mergedItems =
          oldHasUserMessage && !existingHasUserMessage
            ? [...oldItems, ...existingItems]
            : [...existingItems, ...oldItems];
        newItemsByThread[newThreadId] = prepareThreadItems([
          ...mergedItems,
        ]);
        delete newItemsByThread[oldThreadId];
      }

      // Update threadsByWorkspace
      const newThreadsByWorkspace = { ...state.threadsByWorkspace };
      const workspaceThreads = newThreadsByWorkspace[workspaceId];
      if (workspaceThreads) {
        const renamedThreads = workspaceThreads.map((thread) =>
          thread.id === oldThreadId ? { ...thread, id: newThreadId } : thread,
        );
        const dedupedById = new Map<string, ThreadSummary>();
        for (const thread of renamedThreads) {
          const current = dedupedById.get(thread.id);
          if (!current) {
            dedupedById.set(thread.id, thread);
            continue;
          }
          dedupedById.set(thread.id, {
            ...current,
            ...thread,
            updatedAt: Math.max(current.updatedAt, thread.updatedAt),
          });
        }
        newThreadsByWorkspace[workspaceId] = Array.from(dedupedById.values());
      }

      // Update threadStatusById
      const newThreadStatusById = { ...state.threadStatusById };
      if (newThreadStatusById[oldThreadId]) {
        const oldStatus = newThreadStatusById[oldThreadId];
        const existingStatus = newThreadStatusById[newThreadId];
        newThreadStatusById[newThreadId] = existingStatus
          ? {
              isProcessing: oldStatus.isProcessing || existingStatus.isProcessing,
              hasUnread: oldStatus.hasUnread || existingStatus.hasUnread,
              isReviewing: oldStatus.isReviewing || existingStatus.isReviewing,
              processingStartedAt:
                oldStatus.processingStartedAt ?? existingStatus.processingStartedAt,
              lastDurationMs:
                oldStatus.lastDurationMs ?? existingStatus.lastDurationMs,
              heartbeatPulse:
                oldStatus.heartbeatPulse ?? existingStatus.heartbeatPulse ?? 0,
            }
          : oldStatus;
        delete newThreadStatusById[oldThreadId];
      }

      // Update activeTurnIdByThread
      const newActiveTurnIdByThread = { ...state.activeTurnIdByThread };
      if (newActiveTurnIdByThread[oldThreadId] !== undefined) {
        newActiveTurnIdByThread[newThreadId] =
          newActiveTurnIdByThread[oldThreadId] ??
          newActiveTurnIdByThread[newThreadId] ??
          null;
        delete newActiveTurnIdByThread[oldThreadId];
      }

      // Update tokenUsageByThread
      const newTokenUsageByThread = { ...state.tokenUsageByThread };
      if (newTokenUsageByThread[oldThreadId]) {
        newTokenUsageByThread[newThreadId] =
          newTokenUsageByThread[newThreadId] ?? newTokenUsageByThread[oldThreadId];
        delete newTokenUsageByThread[oldThreadId];
      }

      // Update planByThread
      const newPlanByThread = { ...state.planByThread };
      if (newPlanByThread[oldThreadId] !== undefined) {
        newPlanByThread[newThreadId] =
          newPlanByThread[newThreadId] ?? newPlanByThread[oldThreadId];
        delete newPlanByThread[oldThreadId];
      }

      // Update lastAgentMessageByThread
      const newLastAgentMessageByThread = { ...state.lastAgentMessageByThread };
      if (newLastAgentMessageByThread[oldThreadId]) {
        const oldMessage = newLastAgentMessageByThread[oldThreadId];
        const existingMessage = newLastAgentMessageByThread[newThreadId];
        newLastAgentMessageByThread[newThreadId] =
          existingMessage && existingMessage.timestamp > oldMessage.timestamp
            ? existingMessage
            : oldMessage;
        delete newLastAgentMessageByThread[oldThreadId];
      }

      // Update agentSegmentByThread
      const newAgentSegmentByThread = { ...state.agentSegmentByThread };
      if (newAgentSegmentByThread[oldThreadId] !== undefined) {
        newAgentSegmentByThread[newThreadId] = Math.max(
          newAgentSegmentByThread[oldThreadId] ?? 0,
          newAgentSegmentByThread[newThreadId] ?? 0,
        );
        delete newAgentSegmentByThread[oldThreadId];
      }

      // Update threadParentById
      const newThreadParentById = { ...state.threadParentById };
      if (newThreadParentById[oldThreadId]) {
        newThreadParentById[newThreadId] = newThreadParentById[oldThreadId];
        delete newThreadParentById[oldThreadId];
      }
      // Also update any threads that have oldThreadId as parent
      for (const [threadId, parentId] of Object.entries(newThreadParentById)) {
        if (parentId === oldThreadId) {
          newThreadParentById[threadId] = newThreadId;
        }
      }

      // Update hiddenThreadIdsByWorkspace
      const newHiddenThreadIdsByWorkspace = { ...state.hiddenThreadIdsByWorkspace };
      const workspaceHidden = newHiddenThreadIdsByWorkspace[workspaceId];
      if (workspaceHidden?.[oldThreadId]) {
        newHiddenThreadIdsByWorkspace[workspaceId] = {
          ...workspaceHidden,
          [newThreadId]: true,
        };
        delete newHiddenThreadIdsByWorkspace[workspaceId][oldThreadId];
      }

      return {
        ...state,
        activeThreadIdByWorkspace: newActiveThreadIdByWorkspace,
        itemsByThread: newItemsByThread,
        threadsByWorkspace: newThreadsByWorkspace,
        threadStatusById: newThreadStatusById,
        activeTurnIdByThread: newActiveTurnIdByThread,
        tokenUsageByThread: newTokenUsageByThread,
        planByThread: newPlanByThread,
        lastAgentMessageByThread: newLastAgentMessageByThread,
        agentSegmentByThread: newAgentSegmentByThread,
        threadParentById: newThreadParentById,
        hiddenThreadIdsByWorkspace: newHiddenThreadIdsByWorkspace,
      };
    }
    case "appendReasoningSummary": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const updated: ConversationItem = {
        ...base,
        summary: mergeReasoningText(
          "summary" in base ? base.summary : "",
          action.delta,
        ),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next),
        },
      };
    }
    case "appendReasoningSummaryBoundary": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const updated: ConversationItem = {
        ...base,
        summary: addSummaryBoundary("summary" in base ? base.summary : ""),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next),
        },
      };
    }
    case "appendContextCompacted": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const id = `context-compacted-${action.turnId}`;
      if (list.some((entry) => entry.id === id)) {
        return state;
      }
      const compactedMessage: ConversationItem = {
        id,
        kind: "message",
        role: "assistant",
        text: "Context compacted.",
      };
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems([...list, compactedMessage]),
        },
      };
    }
    case "appendReasoningContent": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const updated: ConversationItem = {
        ...base,
        content: mergeReasoningText(
          "content" in base ? base.content : "",
          action.delta,
        ),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next),
        },
      };
    }
    case "appendToolOutput": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      if (index < 0 || list[index].kind !== "tool") {
        return state;
      }
      const existing = list[index];
      const updated: ConversationItem = {
        ...existing,
        output: mergeStreamingText(existing.output ?? "", action.delta),
      } as ConversationItem;
      const next = [...list];
      next[index] = updated;
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next),
        },
      };
    }
    case "addApproval": {
      const exists = state.approvals.some(
        (item) =>
          item.request_id === action.approval.request_id &&
          item.workspace_id === action.approval.workspace_id,
      );
      if (exists) {
        return state;
      }
      return { ...state, approvals: [...state.approvals, action.approval] };
    }
    case "removeApproval":
      return {
        ...state,
        approvals: state.approvals.filter(
          (item) =>
            item.request_id !== action.requestId ||
            item.workspace_id !== action.workspaceId,
        ),
      };
    case "addUserInputRequest": {
      const exists = state.userInputRequests.some(
        (item) =>
          item.request_id === action.request.request_id &&
          item.workspace_id === action.request.workspace_id,
      );
      if (exists) {
        return state;
      }
      return {
        ...state,
        userInputRequests: [...state.userInputRequests, action.request],
      };
    }
    case "removeUserInputRequest":
      return {
        ...state,
        userInputRequests: state.userInputRequests.filter(
          (item) =>
            item.request_id !== action.requestId ||
            item.workspace_id !== action.workspaceId,
        ),
      };
    case "clearUserInputRequestsForThread":
      return {
        ...state,
        userInputRequests: state.userInputRequests.filter(
          (item) =>
            item.workspace_id !== action.workspaceId ||
            item.params.thread_id !== action.threadId,
        ),
      };
    case "setThreads": {
      const hidden = state.hiddenThreadIdsByWorkspace[action.workspaceId] ?? {};
      const existingThreads = state.threadsByWorkspace[action.workspaceId] ?? [];
      // BUG FIX: Preserve engineSource and other info from existing threads when merging
      // This prevents loss of explicitly set engine types (e.g., Claude) when refreshing thread list
      const existingThreadById = new Map(
        existingThreads.map((thread) => [thread.id, thread]),
      );
      const newThreadIds = new Set(action.threads.map((thread) => thread.id));

      // Merge incoming threads with preserved existing info
      const visibleThreads = action.threads
        .filter((thread) => !hidden[thread.id])
        .map((thread) => {
          const existing = existingThreadById.get(thread.id);
          if (existing) {
            // Preserve engineSource if new thread doesn't have one
            const engineSource = thread.engineSource || existing.engineSource;
            // Keep the better name (prefer non-auto-generated names)
            const existingIsAutoGenerated = existing.name.startsWith("Agent ") || /^[a-f0-9]{4,8}$/i.test(existing.name);
            const newIsAutoGenerated = thread.name.startsWith("Agent ") || /^[a-f0-9]{4,8}$/i.test(thread.name);
            const name = newIsAutoGenerated && !existingIsAutoGenerated ? existing.name : thread.name;
            return { ...thread, name, engineSource };
          }
          return thread;
        });

      // BUG FIX: Also preserve threads that are currently active but not in the new list
      // (e.g., newly created Claude threads that haven't been synced to the backend yet)
      const activeThreadId = state.activeThreadIdByWorkspace[action.workspaceId];
      if (activeThreadId) {
        const activeThread = existingThreadById.get(activeThreadId);
        if (activeThread && !newThreadIds.has(activeThreadId) && !hidden[activeThreadId]) {
          // Prepend the active thread to preserve it
          visibleThreads.unshift(activeThread);
        }
      }

      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: visibleThreads,
        },
      };
    }
    case "setThreadListLoading":
      return {
        ...state,
        threadListLoadingByWorkspace: {
          ...state.threadListLoadingByWorkspace,
          [action.workspaceId]: action.isLoading,
        },
      };
    case "setThreadListPaging":
      return {
        ...state,
        threadListPagingByWorkspace: {
          ...state.threadListPagingByWorkspace,
          [action.workspaceId]: action.isLoading,
        },
      };
    case "setThreadListCursor":
      return {
        ...state,
        threadListCursorByWorkspace: {
          ...state.threadListCursorByWorkspace,
          [action.workspaceId]: action.cursor,
        },
      };
    case "setThreadTokenUsage":
      return {
        ...state,
        tokenUsageByThread: {
          ...state.tokenUsageByThread,
          [action.threadId]: action.tokenUsage,
        },
      };
    case "setRateLimits":
      return {
        ...state,
        rateLimitsByWorkspace: {
          ...state.rateLimitsByWorkspace,
          [action.workspaceId]: action.rateLimits,
        },
      };
    case "setAccountInfo":
      return {
        ...state,
        accountByWorkspace: {
          ...state.accountByWorkspace,
          [action.workspaceId]: action.account,
        },
      };
    case "setThreadPlan":
      return {
        ...state,
        planByThread: {
          ...state.planByThread,
          [action.threadId]: action.plan,
        },
      };
    case "clearThreadPlan":
      return {
        ...state,
        planByThread: {
          ...state.planByThread,
          [action.threadId]: null,
        },
      };
    case "incrementAgentSegment": {
      // 当 tool item 开始时调用，增加分段计数，确保后续文本创建新的 message
      const current = state.agentSegmentByThread[action.threadId] ?? 0;
      return {
        ...state,
        agentSegmentByThread: {
          ...state.agentSegmentByThread,
          [action.threadId]: current + 1,
        },
      };
    }
    case "resetAgentSegment":
      // 当 turn 完成时调用，重置分段计数
      return {
        ...state,
        agentSegmentByThread: {
          ...state.agentSegmentByThread,
          [action.threadId]: 0,
        },
      };
    default:
      return state;
  }
}
